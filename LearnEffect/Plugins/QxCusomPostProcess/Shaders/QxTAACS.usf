#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"
#include "/Engine/Private/PostProcessCommon.ush"
#include "/Engine/Private/TextureSampling.ush"

// 这个shader 基本都是参照TAAStandalone.usf实现的

#ifndef AA_MANUALLY_CLAMP_HISTORY_UV
    #define AA_MANUALLY_CLAMP_HISTORY_UV 1
#endif

#ifndef AA_BICUBIC
    #define  AA_BICUBIC 1
#endif

// 当前帧的采样次数
#ifndef AA_SAMPLES
#define AA_SAMPLES 5
#endif

Texture2D  SceneColorTexture;
Texture2D HistoryTexture;
SamplerState HistoryTextureSampler;



float4 OutputViewportSize;
float4 OutputViewportRect;
float4  ScreenPosToHistoryTextureUV;
float4 HistoryBufferSize;
float4 HistoryBufferUVMinMax;

float4 InputSceneColorSize;
float4 ViewportUVToInputBufferUV;

int2 InputMinPixelCoord;
int2 InputMaxPixelCoord;

float2 ScreenPosAbsMax;
float CurrentFrameWeight;

float PlusWeights[5];

RWTexture2D<float4> OutputComputeTex;

// ---------- Constants -----------

// 周围9个像素的offset
static const int2 kOffsets3x3[9] =
{
    int2(-1, -1),
    int2( 0, -1),
    int2( 1, -1),
    int2(-1,  0),
    int2( 0,  0), // K
    int2( 1,  0),
    int2(-1,  1),
    int2( 0,  1),
    int2( 1,  1),
};

// indexes of the offset to have plus + shape
static const uint kPlusIndexes3x3[5] = {1, 3, 4, 5, 7};

// Numbers of Neighbors
static const uint kNeighborsCount = 9;

struct FTAAInputParameters
{

    uint2 GroupId;
    uint2 GroupThreadId;
    uint GroupThreadIndex;

    float FrameExposureScale;
    // Viewport UV of the output pixel
    float2 ViewportUV;

    // position of the output pixel on screen
    float2 ScreenPos;

    // Buffer UV of the nearest input pixel
    float2 NearestBufferUV;

    float4 CachedNeighbors0[kNeighborsCount];
};

struct FTAAIntermediaryResult
{
    float4 FilteredColor;

    float FilteredTemporalWeight;
};

// Transformed scene color data for a sample
struct FTAASceneColorSample
{
    // Transformed scene color and alpha channel
    float4 Color;

    // HDR weight of the scene color sample
    float HdrWeight;
};

// ----------Scene Color Space Management ------------
// Transform Raw linear scene color RGB to TAA's working color space
float4 TransformSceneColor(float4 RawLinearSceneColorRGBA)
{
    return RawLinearSceneColorRGBA;
}


float4 SampleHistory(in float2 HistoryScreenPosition)
{
    float4 RawHistory = 0;

    // 不知道为什么实际测试来看用不用bi cubic的区别几乎看不出来
    #if AA_BICUBIC
    {
        float2 HistoryBufferUV = HistoryScreenPosition * ScreenPosToHistoryTextureUV.xy + ScreenPosToHistoryTextureUV.zw;
        #if AA_MANUALLY_CLAMP_HISTORY_UV
            HistoryBufferUV = clamp(HistoryBufferUV, HistoryBufferUVMinMax.xy, HistoryBufferUVMinMax.zw);
        #endif

        FCatmullRomSamples Samples = GetBicubic2DCatmullRomSamples(
            HistoryBufferUV,
            HistoryBufferSize.xy,
            HistoryBufferSize.zw);
        for (uint i = 0; i < Samples.Count; ++i)
        {
            float2 SampleUV = Samples.UV[i];

            if (AA_MANUALLY_CLAMP_HISTORY_UV)
            {
                if (Samples.UVDir[i].x < 0)
                {
                    SampleUV.x = max(SampleUV.x, HistoryBufferUVMinMax.x);
                } else if (Samples.UVDir[i].x > 0)
                {
                    SampleUV.x = min(SampleUV.x, HistoryBufferUVMinMax.z);
                }

                if (Samples.UVDir[i].y < 0)
                {
                    SampleUV.y = max(SampleUV.y, HistoryBufferUVMinMax.y);
                } else if (Samples.UVDir[i].y > 0)
                {
                    SampleUV.y = min(SampleUV.y, HistoryBufferUVMinMax.w);
                }
            }
            RawHistory += HistoryTexture.SampleLevel(HistoryTextureSampler, SampleUV, 0) * Samples.Weight[i];
        }
        RawHistory *= Samples.FinalMultiplier;
        // RawHistory = float4(1, 0, 0, 1);
    }
    #else
    if (AA_MANUALLY_CLAMP_HISTORY_UV)
    {
        HistoryScreenPosition = clamp(HistoryScreenPosition, -ScreenPosAbsMax, ScreenPosAbsMax);
    }

    float2 HistoryTextureUV = HistoryScreenPosition * ScreenPosToHistoryTextureUV.xy + ScreenPosToHistoryTextureUV.zw;
    RawHistory = HistoryTexture.SampleLevel(HistoryTextureSampler, HistoryTextureUV, 0);
    #endif
    return RawHistory;
}

// Luma include a scaling by 4
float Luma4(float3 Color)
{
    return (Color.g * 2.0) + (Color.r + Color.b);
}

// Optimized HDR Weighting function
float HdrWeight4(float3 Color, float Exposure)
{
    return rcp(Luma4(Color) * Exposure + 4.0);
}

float GetSceneColorHdrWeight(
    in FTAAInputParameters InputParameters,
    float4 SceneColor
    )
{
    return HdrWeight4(SceneColor.rgb, InputParameters.FrameExposureScale);
}

void PrecacheInputSceneColor(inout  FTAAInputParameters InputParameters)
{
    // Precache 3x3 input scene color into FTAAInputParameters::CachecNeighbors
    UNROLL
    for (uint i = 0; i < kNeighborsCount; ++i)
    {
        int2 Coord = int2(InputParameters.NearestBufferUV * InputSceneColorSize.xy) + kOffsets3x3[i];
        Coord = clamp(Coord, InputMinPixelCoord, InputMaxPixelCoord);

        InputParameters.CachedNeighbors0[i] = SceneColorTexture[Coord];
    }
}

FTAASceneColorSample SampleCachedSceneColorTexture(
    inout FTAAInputParameters InputParams,
    int2 PixelOffset
    )
{
    // PixelOffset is const at compile time, Therefor all this computation is actually free
    uint NeighborsId = uint(4 + PixelOffset.x + PixelOffset.y * 3);
    FTAASceneColorSample ColorSample;

    ColorSample.Color = InputParams.CachedNeighbors0[NeighborsId];
    
    ColorSample.HdrWeight = GetSceneColorHdrWeight(InputParams, ColorSample.Color);
    return ColorSample;
}

void FilterCurrentFrameInputSamples(
    in FTAAInputParameters InputParams,
    inout FTAAIntermediaryResult IntermediaryResult
    )
{
    float4 OutColor = 0;

    #if AA_SAMPLES == 9
    #elif  AA_SAMPLES == 5
        const uint SampleIndexes[5] = kPlusIndexes3x3; 
    #endif

    float NeighborsHdrWeight = 0;
    float NeighborsFinalWeight = 0;
    float4 NeighborsColor = 0;

    UNROLL
    for (uint i = 0; i < AA_SAMPLES; ++i)
    {
        // Get the sample offset from the nearest input pixel
        int2 SampleOffset;
        const uint SampleIndex = SampleIndexes[i];
        SampleOffset = kOffsets3x3[SampleIndex];

        float2 fSampleOffset = float2(SampleOffset);
        float SampleSpatialWeights = PlusWeights[i];

        FTAASceneColorSample SceneColorSample =  SampleCachedSceneColorTexture(InputParams, SampleOffset);
    }
}

FTAAIntermediaryResult CreateIntermediaryResult()
{
    // Disable warning X4008: floating point division by zero
    #pragma warning(disable:4008)
    FTAAIntermediaryResult IntermediaryResult = (FTAAIntermediaryResult) (1.0 / 0.0);
#pragma warning(default:4008)

    IntermediaryResult.FilteredColor = 1;
    IntermediaryResult.FilteredTemporalWeight = 1;
    return IntermediaryResult;
}

float2 WeightedLerpFactors(float WeightA, float WeightB, float Blend)
{
    float BlendA = (1 - Blend) * WeightA;
    float BlendB = Blend * WeightB;
    float RcpBlend = rcp(BlendA + BlendB);
    BlendA *= RcpBlend;
    BlendB *= RcpBlend;
    return float2(BlendA, BlendB);
}

float4 QxTemporalAASample(
    uint2 GroupId,
    uint2 GroupThreadId,
    uint GroupThreadIndex,
    uint2 DispatchThreadId,
    float2 ViewportUV)
{
    // Setup
    FTAAInputParameters InputParams;

    // Perpixel input setup
    {
        InputParams.GroupId = GroupId;
        InputParams.GroupThreadId = GroupThreadId;
        InputParams.GroupThreadIndex = GroupThreadIndex;
        InputParams.ViewportUV = ViewportUV;
        InputParams.ScreenPos = ViewportUVToScreenPos(ViewportUV);
        InputParams.NearestBufferUV = ViewportUV * ViewportUVToInputBufferUV.xy + ViewportUVToInputBufferUV.zw;
        
        InputParams.FrameExposureScale = 1.f; 
    }

    FTAAIntermediaryResult IntermediaryResult = CreateIntermediaryResult();
    
    
    float4 OutputColor = 0;

    // float4 HistoryColor = HistoryTexture[DispatchThreadId];
    // float4 HistoryColor = HistoryTexture.SampleLevel(HistoryTextureSampler, ViewportUV, 0);

    // Camera motion for pixel and nearest pixel in screen space
    bool OffScreen = false;
    float Velocity = 0;
    float HistoryBlur = 0;
    float2 HistoryScreenPosition = InputParams.ScreenPos;
    {
            
    }
    
    float4 HistoryColor = SampleHistory(HistoryScreenPosition);
    float4 CurrentFrameColor = SceneColorTexture[DispatchThreadId];

    PrecacheInputSceneColor(InputParams); //In out
    
    FilterCurrentFrameInputSamples(
        InputParams,
        IntermediaryResult //Inout
        );

    // Compute Blend amount
    float BlendFinal = 1.f;
    {
        
    }

    float CurFrameWeight = GetSceneColorHdrWeight(InputParams, IntermediaryResult.FilteredColor);
    float HistoryWeight = GetSceneColorHdrWeight(InputParams, HistoryColor);
    OutputColor = lerp(HistoryColor, CurrentFrameColor, CurrentFrameWeight);
    {
        float2 Weight = WeightedLerpFactors(HistoryWeight, CurFrameWeight, BlendFinal);
        OutputColor = HistoryColor * Weight.x +  IntermediaryResult.FilteredColor * Weight.y;
    }
    
    return OutputColor;
}


// float2 InputViewportSize;
[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]
void MainCS(
    uint2 DispatchThreadId : SV_DispatchThreadID,
    uint2 GroupId : SV_GroupID,
    uint2 GroupThreadId : SV_GroupThreadID,
    uint GroupThreadIndex : SV_GroupIndex
    )
{
    float2 ViewportUV = (float2(DispatchThreadId) + 0.5f) * OutputViewportSize.zw;


    float4 OutColor0 = 0;
    // OutColor0 = QxTemporalAASample(GroupId, GroupThreadId, GroupThreadIndex, ViewportUV);
    // OutColor0 = OutputComputeTex[DispatchThreadId];
    // OutputComputeTex[DispatchThreadId] = HistoryTexture[DispatchThreadId];
    OutColor0 = QxTemporalAASample(GroupId, GroupThreadId, GroupThreadIndex, DispatchThreadId, ViewportUV);
    OutputComputeTex[DispatchThreadId] = OutColor0;
    // uint2 PixelPos = DispatchThreadId + OutputViewportRect.xy;
    // if (all(PixelPos < OutputViewportRect.zw))
    // {
    //     float4 FinalOutput = min(MaxHalfFloat.xxxx, OutColor0);
    //
    //     OutColor0[PixelPos] = FinalOutput;
    // }
}